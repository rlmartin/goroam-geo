goroam.google.maps.version = '2.176';
if ((goroam.browser.host_info().name == goroam.enm.browsers.safari) && (goroam.browser.host_info().major_ver < 525)) goroam.google.maps.version = '';

if (goroam.google.maps.version != '') {
	google.load('maps', goroam.google.maps.version);
} else {
	alert('<%= Constant::get(:error_header) %><%= Constant::get(:error_browser_not_supported) %>');
}

// Load local variables for functions.
goroam.google.maps.__active_map = undefined;
goroam.google.maps.__active_map_id = '<%= @settings[:map] %>';
goroam.google.maps.__count_of_page_lat_lng = 0;
goroam.google.maps.__count_of_processing_addr = 0;
goroam.google.maps.__page_maps = {};
goroam.google.maps.__addr_attr = '<%= Constant::get(:addr_attribute) %>';
goroam.google.maps.__lat_attr = '<%= Constant::get(:lat_attribute) %>';
goroam.google.maps.__lng_attr = '<%= Constant::get(:lng_attribute) %>';
goroam.google.maps.__map_attr = '<%= Constant::get(:map_attribute) %>';

// I added this because the real version uses event listeners, which are called in
// opposite directions in IE vs Moz (FIFO vs FILO).  I added this so that it would
// have the same functionality, but would work as FIFO in all browsers.
google.__setOnLoadCallback = google.setOnLoadCallback;
google.__onload_callback_functions = [];
google.__onload_callback = function(e) {
	for (var i = 0; i < google.__onload_callback_functions.length; i++) {
		google.__onload_callback_functions[i](e);
	}
};
google.__setOnLoadCallback(google.__onload_callback);
google.setOnLoadCallback = function(fFunc) { google.__onload_callback_functions.add_if_new(fFunc); };


/********************************
 * FUNCTION:	extend_functionality
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function extends the out-of-the-box Google Maps objects.
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.extend_functionality = function() {
  // Map2 object extensions
  // New "local" variables
  google.maps.Map2.prototype.active_marker = undefined;
  google.maps.Map2.prototype.__bounds = undefined;
  google.maps.Map2.prototype.__lines = undefined;

  // New methods
  google.maps.Map2.prototype.add_lat_lng = function(dLat, dLng, strAnchor, strAnchorText) {
    var strKey = dLat + '_' + dLng;
    if (!this.__lat_lng) this.__lat_lng = {};
    if (this.__lat_lng[strKey]) {
      // Do something here for multiple hits on the same lat/lng.
    } else {
      var objLatLng = new google.maps.LatLng(dLat, dLng);
      var objMarker = goroam.google.maps.create_marker(objLatLng);
      this.__lat_lng[strKey] = objMarker;
      this.addOverlay(this.__lat_lng[strKey]);
      this.get_bounds().extend(objLatLng);
    }
		// Add menu items if the anchor is given.
		strAnchor = (strAnchor || '').trim();
		strAnchorText = (strAnchorText || '').trim();
		if ((strAnchor != '') && (strAnchorText != '')) {
			var objMarker = this.__lat_lng[strKey];
			if (!objMarker.__menu) {
				objMarker.__menu = new goroam.google.maps.html_overlay({ class_name: '<%= Constant::get(:css_prefix) %>point_menu', container: document.createElement('ul'), lat_lng: objLatLng, position: 'se'});
				this.addOverlay(objMarker.__menu);
				goroam.event.bind(objMarker, 'click', objMarker, objMarker.trigger_hide_menus);
				goroam.event.bind(objMarker, 'click', objMarker.__menu.get_container(), goroam.dhtml.toggle_me);
				goroam.event.bind(this.getContainer(), 'hide_menus', objMarker, objMarker.hide_menu);
			}
			var elItem = document.createElement('li');
			var elAnchor = document.createElement('a');
			elAnchor.href = '#' + strAnchor;
			elAnchor.innerHTML = strAnchorText;
			goroam.dhtml.edit_class_name(elItem, 'point_menu_item');
			elItem.appendChild(elAnchor);
			objMarker.__menu.get_container().appendChild(elItem);
			if ((objMarker.__menu.get_container().childNodes.length % 2) == 0) goroam.dhtml.edit_class_name(elItem, 'odd_row');
		}
    // Return the object that was created.
    return this.__lat_lng[strKey];
  }

  google.maps.Map2.prototype.__addOverlay = google.maps.Map2.prototype.addOverlay;
  google.maps.Map2.prototype.addOverlay = function(objOverlay) {
    this.__addOverlay(objOverlay);
    objOverlay.map = this;
  }
  google.maps.Map2.prototype.__removeOverlay = google.maps.Map2.prototype.removeOverlay;
  google.maps.Map2.prototype.removeOverlay = function(objOverlay) {
    this.__removeOverlay(objOverlay);
    objOverlay.map = undefined;
  }

	// This function adds a directions line to the map.  If the line is not ready, it will try again.
	google.maps.Map2.prototype.add_directions_line = function(objDirections, strColor, iWidth, dOpacity, iTravelMode) {
		goroam.google.maps.add_directions_line_to_map(this, objDirections, strColor, iWidth, dOpacity, iTravelMode);
	}

	// This function adds a point to the line on the map.  If the line does not already exist, it will be created.
	google.maps.Map2.prototype.add_point_to_line = function(strLineId, objLatLng, iIndex, strRouteType, strColor, iWidth, dOpacity) {
		goroam.google.maps.add_point_to_line(this, strLineId, objLatLng, iIndex, strRouteType, strColor, iWidth, dOpacity);
	}

  // This function creates a marker in the given lat/lng, or at the center of the map if one is not given.
  // Use the bolDraggable flag to make the marker draggable.
  google.maps.Map2.prototype.create_active_marker = function(objLatLng, bolDraggable) {
    objLatLng = (objLatLng || this.getCenter());
    this.active_marker = goroam.google.maps.create_marker(objLatLng, {draggable: true});
    this.addOverlay(this.active_marker);
    goroam.event.addListener(this.active_marker, 'dragend', function(objLatLng) { goroam.event.trigger(this.map, 'location_found', objLatLng); });
  }

	// This function extends the map bounds to include the given LatLng.
	google.maps.Map2.prototype.extend_bounds = function(objLatLng) {
		this.get_bounds().extend(objLatLng);
		this.resize_to_bounds();
	}

	// This function gets the map's internal bounds object.
	google.maps.Map2.prototype.get_bounds = function() {
		if (!this.__bounds) this.__bounds = new google.maps.LatLngBounds();
		return this.__bounds;
	}

	// This function gets the array of lines already on the map.
	google.maps.Map2.prototype.get_line_array = function() {
		if (!this.__lines) this.__lines = [];
		return this.__lines;
	}

  // This function searched for the given location and recenters the map on that location if found.
  google.maps.Map2.prototype.goto_location = function(strLocation) {
    goroam.google.maps.find_location(this, strLocation, function(objPoint, strAddress, objPlacemark) {
      if (objPlacemark && objPlacemark.ExtendedData && objPlacemark.ExtendedData.LatLonBox) {
        this.recenter_active_marker(objPoint, new google.maps.LatLngBounds(new google.maps.LatLng(objPlacemark.ExtendedData.LatLonBox.south, objPlacemark.ExtendedData.LatLonBox.west), new google.maps.LatLng(objPlacemark.ExtendedData.LatLonBox.north, objPlacemark.ExtendedData.LatLonBox.east)));
      } else {
        this.recenter_active_marker(objPoint);
      }
      goroam.event.trigger(this, 'location_found', objPoint, strAddress, objPlacemark); });
  }

  // This function moves the active marker to a given lat/lng and recenters/resizes the map on that point.
  // objZoom can be either a zoom level (int) or a GLatLngBounds object.
  google.maps.Map2.prototype.recenter_active_marker = function(objLatLng, objZoom) {
    if (this.active_marker) {
      // Change the lat/lng of the marker if it already exists.
      this.active_marker.setLatLng(objLatLng);
    } else {
      // Create the marker if it does not already exist.
      this.create_active_marker(objLatLng, false);
    }
    // Recenter the map on the moved marker.
    if (goroam.system.is_numeric(objZoom) || (objZoom == undefined)) {
      this.setCenter(objLatLng, objZoom);
    } else {
      this.resize_to_bounds(objZoom);
    }
  }
	// A function to turn on recentering of the active marker when the given event is triggered.
	google.maps.Map2.prototype.recenter_active_marker_on_event = function(strEvent) {
		strEvent = strEvent.toLowerCase();
		if (strEvent == 'dblclick') this.disableDoubleClickZoom();
		google.maps.Event.addListener(this, strEvent, function(objOverlay, objLatLng) { this.recenter_active_marker(objLatLng); });
	}
  
  // This function resizes and recenters the map based on either a) the optional bounds object or b) the map's
  // internal bounds object.  Returns true upon success.
  google.maps.Map2.prototype.resize_to_bounds = function(objLatLngBounds) {
    var bolResult = false;
    // Default to resizing to the map's bounds.
    objLatLngBounds = (objLatLngBounds || this.get_bounds());
    if (objLatLngBounds && !objLatLngBounds.isEmpty()) {
      var iZoom = this.getBoundsZoomLevel(objLatLngBounds);
      this.setCenter(objLatLngBounds.getCenter(), iZoom);
    }
    return bolResult;
  }



  // This function shows a focus_overlay at the given lat/lng point.
  google.maps.Map2.prototype.show_focus = function(objLatLng) {
    if (!this.__focus_overlay) {
      this.__focus_overlay = goroam.google.maps.create_focus_overlay(objLatLng);
      this.addOverlay(this.__focus_overlay);
    } else {
      if (this.__focus_overlay.map != this) this.addOverlay(this.__focus_overlay);
      this.__focus_overlay.setLatLng(objLatLng);
    }
  }



  // These functions show/hide a GLayer on the map.
  google.maps.Map2.prototype.show_layer = function(strId) {
    if (!this.__layers) this.__layers = {};
    if (!this.__layers[strId]) {
      this.__layers[strId] = new google.maps.Layer(strId);
      this.addOverlay(this.__layers[strId]);
    }
    this.__layers[strId].show();
  }
  google.maps.Map2.prototype.hide_layer = function(strId) {
    if (!this.__layers) this.__layers = {};
    if (this.__layers[strId]) this.__layers[strId].hide();
  }



  // This function triggers the 'hide_menus' event for the map.
  google.maps.Marker.prototype.trigger_hide_menus = function() {
		if (this.map) goroam.event.trigger(this.map.getContainer(), 'hide_menus', this);
  }



  // This function hides a menu for the current marker.
  google.maps.Marker.prototype.hide_menu = function(objTarget) {
		if (this.__menu && (this != objTarget)) goroam.dhtml.hide(this.__menu.get_container());
  }



  /********************************
   * OBJECT:	html_overlay
   * WRITTEN BY:	Ryan Martin
   * WRITTEN ON:	2006.05.13
   * DESCRIPTION:	This object is used to place any HTML onto a Google Map at a given
   *		latitude/longitude.
   * BROWSERS:	IE		Good
   *		Firefox		Good
   *		Netscape	Good
   * PARAMETERS:	arrInit		A named map array of init values (as follows:)
   *					class_name	Optional. A className to assign to the container for CSS.
   *					container	Optional. The HTML element to place on the map. If not given, a new DIV is created.
   *					lat_lng		A LatLng object, at which the HTML should be located.
  external to the object.
   *					position	Optional. The compass_position of the object relative to the lat_lng. Defaults to centered.
   * RETURNS:	The GHTML object
   */

  goroam.google.maps.html_overlay = function(arrInit) {
    var _self = this;
    // Create the container for the object.
    if (arrInit && arrInit.container) {
      _self.__container = arrInit.container;
    } else {
      _self.__container = document.createElement('div');
    }
    // Make sure the container has a default className and any given className.
    goroam.dhtml.edit_class_name(_self.__container, '<%= Constant::get(:css_prefix) %>html_overlay' + ((arrInit && arrInit.class_name) ? ' ' + arrInit.class_name : ''), '', true);
    // Set the LatLng
    if (arrInit && arrInit.lat_lng) _self.__lat_lng = arrInit.lat_lng;
    // Set the position; defaults to empty string.
    _self.__position = (arrInit && arrInit.position) ? arrInit.position : '';
  };
  // The object is based off of empty GOverlay class.
  goroam.google.maps.html_overlay.prototype = new google.maps.Overlay();
  // Copy the html_overlay into a new object.
  goroam.google.maps.html_overlay.prototype.copy = function() {
	  var _self = this;
	  var objCopy = new goroam.google.maps.html_overlay({container: _self.__container.cloneNode(true), lat_lng: _self.__lat_lng, position: _self.__position});
	  // Create a copy of the object with the new unique ID.
	  return objCopy;
  }
  // A method used to get the overlay's HTML container.
  goroam.google.maps.html_overlay.prototype.get_container = function() {
    return this.__container;
  }
  // A method used to get the overlay's lat/lng point.
  goroam.google.maps.html_overlay.prototype.getLatLng = function() {
    return this.__lat_lng;
  }
  // Initialize the html_overlay object by adding it to the map.
  goroam.google.maps.html_overlay.prototype.initialize = function(objMap) {
	  var _self = this;
	  _self.__container.style.position = 'absolute';
	  _self.map = objMap;
	  _self.map.getPane(G_MAP_MARKER_PANE).appendChild(_self.__container);
  };
  // Move the html_overlay to a new point on the map.
  goroam.google.maps.html_overlay.prototype.setLatLng = function(objLatLng) {
	  var _self = this;
	  var bolResult = false;
	  if (objLatLng) {
		  _self.__lat_lng = objLatLng;
		  _self.redraw(true);
		  bolResult = true;
	  }
	  return bolResult;
  };
  // Redraw the HTML node based on the current projection and zoom level.
  goroam.google.maps.html_overlay.prototype.redraw = function(force) {
	  var _self = this;
	  // We only need to redraw if the coordinate system has changed
	  if (!force || !(_self.map)) return;
	  // Calculate the DIV location based on the map location and zoom level.
	  var objCenter = _self.map.fromLatLngToDivPixel(_self.__lat_lng);

	  // Now position our DIV based on the map's DIV coordinates.
	  var objPosition = new goroam.math.compass_position(_self.__position);
	  _self.__container.style.left = objPosition.get_left(objCenter.x, _self.__container.offsetWidth) + 'px';
	  _self.__container.style.top = objPosition.get_top(objCenter.y, _self.__container.offsetHeight) + 'px';
  };
  // Remove the html_overlay from the map pane
  goroam.google.maps.html_overlay.prototype.remove = function() {
    var elContainer = this.__container;
    elContainer.parentNode.removeChild(elContainer);
  };
}



/********************************
 * FUNCTION:	add_directions_line_to_map
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.18
 * DESCRIPTION:	This function adds a directions line to the map if it is ready.  If the directions are updated, the line will also be updated,
 *							so there is no need to re-add the line after the first time.
 * PARAMETERS:	objMap				The Map to add the line to.
 *							objDirections	The GDirections object to check for the Polyline.
 * RETURNS:			none
 */
goroam.google.maps.add_directions_line_to_map = function(objMap, objDirections, strColor, iWidth, dOpacity, iTravelMode) {
	var objStatus = objDirections.getStatus();
	if (objStatus && objStatus.code == 200) {
		var objLine = objDirections.getPolyline();
		var objOptions = {};
		objMap.addOverlay(objLine);
		if (strColor) objOptions.color = strColor;
		if (iWidth) objOptions.weight = iWidth;
		if (dOpacity) objOptions.opacity = dOpacity;
		objLine.setStrokeStyle(objOptions);
		//objMap.
	} else if (!objStatus || (objStatus.code == 500)) {
		window.setTimeout(function() { goroam.google.maps.add_directions_line_to_map(objMap, objDirections, strColor, iWidth, dOpacity); }, 100);
	} else if (objStatus && (objStatus.code == 620)) {
		// If the error is due to too many requests, attempt loading it again.
		objDirections.loadFromWaypoints(objDirections._waypoints, { getPolyline: true, preserveViewport: true, travelMode: (iTravelMode || G_TRAVEL_MODE_DRIVING) });
		window.setTimeout(function() { goroam.google.maps.add_directions_line_to_map(objMap, objDirections, strColor, iWidth, dOpacity); }, 100);
	}
}



/********************************
 * FUNCTION:	add_point_to_line
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.13
 * DESCRIPTION:	This function adds a point to the line indicated by the given id.
 * PARAMETERS:	objMap			The Map to add the line/point to.
 *							strLineId		The ID of the line to add the point to.
 *							objLatLng   The lat/lng point to add to the line.
 *							iIndex			Optional. The place in the line at which to add the point.  Defaults to the end.
 *							strRouteType Optional. The type of 'directions' route to use: walking or driving. If not given or blank, use direct route.
 *							strColor		Optional. The RGB color to use when adding the first point to a new line. Defaults to the color in the settings.
 *							iWidth			Optional. The width to use when adding the first point to a new line. Defaults to the width in the settings.
 *							dOpacity		Optional. The opacity to use when adding the first point to a new line. Defaults to the opacity in the settings.
 * RETURNS:	The newly created goroam.google.maps.html_overlay
 */
goroam.google.maps.add_point_to_line = function(objMap, strLineId, objLatLng, iIndex, strRouteType, strColor, iWidth, dOpacity) {
	var objLine;
	// Load line settings
	strRouteType = ((strRouteType || '') == '' ? '<%= @settings[:line_on_roads] %>' : strRouteType);
	var bolFollowRoads = false;
	switch (strRouteType) {
		case 'walking':
		case 'driving':
		case 'yes':
			bolFollowRoads = true;
	}
	strColor = (strColor || '<%= @settings[:line_color] %>');
	dOpacity = (dOpacity || parseFloat('<%= @settings[:line_opacity] %>'));
	iWidth = (iWidth || parseInt('<%= @settings[:line_width] %>'));
	// If the point passed in is a marker instead of a geo point
	if (objLatLng.getLatLng) objLatLng = objLatLng.getLatLng();
	// Different processing is required for lines that follow roads vs those that don't.
	if (bolFollowRoads) {
		var bolNewDirections = false;
		// For 'directions' lines, the stored line is an array of line segments.
		objLine = objMap.get_line_array()[strLineId];
		var iSegmentIndex = 0;
		if (objLine) {
			// The segment index is linked to the given index, or is the index of the latest segment if the index is not given.
			iSegmentIndex = (iIndex ? Math.floor(iIndex / parseInt('<%= Constant::get(:follow_roads_max_per_line) %>')) : objLine.length - 1);
			// If the segment has hit the maximum, increase the segment index by 1.
			if (objLine[iSegmentIndex] && objLine[iSegmentIndex]._waypoints && objLine[iSegmentIndex]._waypoints.length == parseInt('<%= Constant::get(:follow_roads_max_per_line) %>')) iSegmentIndex++;
		} else {
			objLine = [];
			objMap.get_line_array()[strLineId] = objLine;
		}
		if (!objLine[iSegmentIndex]) {
			// Walking directions requires a DIV for the directions.
			objLine[iSegmentIndex] = new google.maps.Directions(undefined, (strRouteType == 'walking' ? goroam.google.maps.get_hidden_directions_container(iSegmentIndex) : undefined));
			bolNewDirections = true;
		}
		// Switch to dealing only with the individual segment
		objLine = objLine[iSegmentIndex];
		if (!objLine._waypoints) objLine._waypoints = [];
		// Calculate the index within the given segment.
		iIndex = (iIndex ? iIndex - (iSegmentIndex * parseInt('<%= Constant::get(:follow_roads_max_per_line) %>')) + iSegmentIndex : objLine._waypoints.length);
		if (iIndex < 0) iIndex = 0;
		// Subsequent segments should include the final point of the previous segment to correctly connect the lines.
		if (iSegmentIndex > 0) {
			if (iIndex == 0) {
				var objWaypoints = objMap.get_line_array()[strLineId][iSegmentIndex - 1]._waypoints;
				objLine._waypoints[0] = objWaypoints[objWaypoints.length - 1];
				iIndex++;
			}
		}
		objLine._waypoints[iIndex] = objLatLng.toString();
		objLine.clear();
		var iTravelMode = G_TRAVEL_MODE_DRIVING;
		if (strRouteType == 'walking') iTravelMode = G_TRAVEL_MODE_WALKING;
		objLine._updated = true;
		// Google maps only allows a certain number of directions requests within a period of time, so delay the request until the line is more
		// fully loaded.
		window.setTimeout(function() {
			if (objLine._updated) {
				objLine.loadFromWaypoints(objLine._waypoints, { getPolyline: true, preserveViewport: true, travelMode: iTravelMode });
				objLine._updated = false;
			}
		}, parseInt('<%= Constant::get(:follow_roads_calc_delay) %>'));
		if (bolNewDirections) objMap.add_directions_line(objLine, strColor, iWidth, dOpacity, iTravelMode);
	} else {
		objLine = objMap.get_line_array()[strLineId];
		if (!objLine) {
			objLine = new google.maps.Polyline([], strColor, iWidth, dOpacity);
			objMap.addOverlay(objLine);
			objMap.get_line_array()[strLineId] = objLine;
		}
		iIndex = (iIndex || objLine.getVertexCount());
		objLine.insertVertex(iIndex, objLatLng);
	}
	objMap.extend_bounds(objLatLng);
}



/********************************
 * FUNCTION:	create_focus_overlay
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.29
 * DESCRIPTION:	This function creates an html_overlay.
 * PARAMETERS:	objLatLng   The lat/lng point where the overlay should be placed.
 * RETURNS:	The newly created goroam.google.maps.html_overlay
 */
goroam.google.maps.create_focus_overlay = function(objLatLng) {
  var objResult = new goroam.google.maps.html_overlay({lat_lng: objLatLng, class_name: '<%= Constant::get(:css_prefix) %>focus_overlay'});
  objResult.__redraw = objResult.redraw;
  objResult.redraw = function(bolForce) {
    var _self = this;
    // Turn on stage 1.
    goroam.dhtml.edit_class_name(_self.get_container(), 'focus_overlay_stage1');
    _self.__redraw(bolForce);
    window.setTimeout(function() {
      goroam.dhtml.edit_class_name(_self.get_container(), 'focus_overlay_stage2', 'focus_overlay_stage1');
      _self.__redraw(bolForce);
      window.setTimeout(function() {
        goroam.dhtml.edit_class_name(_self.get_container(), 'focus_overlay_stage3', 'focus_overlay_stage2');
        _self.__redraw(bolForce);
        window.setTimeout(function() {
          goroam.dhtml.edit_class_name(_self.get_container(), '', 'focus_overlay_stage3');
          _self.__redraw(bolForce);
          _self.map.removeOverlay(_self);
        }, parseInt('<%= Constant::get(:focus_overlay_interval) %>'));
      }, parseInt('<%= Constant::get(:focus_overlay_interval) %>'));
    }, parseInt('<%= Constant::get(:focus_overlay_interval) %>'));
  }
  return objResult;
}



/********************************
 * FUNCTION:	create_marker
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.29
 * DESCRIPTION:	This function creates a Google Maps Marker, with some default settings.
 * PARAMETERS:	The same as a typical google.maps.Marker:
 *              objLatLng   The lat/lng point where the marker should be placed.
 *              objOptions  The options to use when creating the marker.
 * RETURNS:	The newly created google.maps.Marker
 */
goroam.google.maps.create_marker = function(objLatLng, objOptions) {
  var bolDraggable = false;
  if (objOptions && objOptions.draggable) bolDraggable = objOptions.draggable;
  if (!objOptions) objOptions = {};
  objOptions.draggable = true;
  objOptions.icon = goroam.google.maps.create_stock_icon('<%= @settings[:marker_icon] %>');
  var objResult = new google.maps.Marker(objLatLng, objOptions);
  if (!bolDraggable) objResult.disableDragging();
  return objResult;
}



/********************************
 * FUNCTION:	create_icon
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.02.27
 * DESCRIPTION:	This function creates a Google Maps Icon, with settings based on the given settings.
 * PARAMETERS:	objSettings     The settings to use to create the icon.
 *              strImageFolder  A root folder to use for image settings; can be blank.
 * RETURNS:     The newly created google.maps.Icon
 */
goroam.google.maps.create_icon = function(objSettings, strImageFolder) {
  var objResult = new google.maps.Icon();
  strImageFolder = (strImageFolder || '');
  for (var strName in objSettings) {
    switch (strName) {
      case 'image':
      case 'printImage':
      case 'printShadow':
      case 'shadow':
      case 'transparent':
        objResult[strName] = strImageFolder + objSettings[strName];
        break;
      default:
        objResult[strName] = objSettings[strName];
    }
  }
  return objResult;
}



/********************************
 * FUNCTION:	create_stock_icon
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.02.27
 * DESCRIPTION:	This function creates a Google Maps Icon, with settings based on the requested icon type.
 * PARAMETERS:	strType   The type of icon being requested
 * RETURNS:     The newly created google.maps.Icon
 */
goroam.google.maps.create_stock_icon = function(strType) {
  strType = (strType || goroam.enm.icons.pushpin.orange).toLowerCase();
  var strRootFolder = '<%= Constant::get(:root_url) %>/images/icons/markers/';
  var objSettings, objResult;
  switch (strType) {
    case goroam.enm.icons.pushpin.blue:
    case goroam.enm.icons.pushpin.green:
    case goroam.enm.icons.pushpin.orange:
    case goroam.enm.icons.pushpin.red:
      objSettings = { iconAnchor: new google.maps.Point(9,32), iconSize: new google.maps.Size(32,32), image: 'red_pushpin.png', imageMap: [9,32, 10,29, 11,25, 5,16, 10, 12, 14,6, 12,2, 14,0, 18,0, 26,6, 21,15, 23,18, 23,22, 20,24, 14,25, 11,32], infoWindowAnchor: new google.maps.Point(9,32), printImage: 'red_pushpin.gif', printShadow: 'pushpin_shadow.gif', shadow: 'pushpin_shadow.png', shadowSize: new google.maps.Size(59,32), transparent: 'pushpin_transparent.png' };
      switch (strType) {
        case goroam.enm.icons.pushpin.blue:
          objSettings.image = 'blue_pushpin.png';
          objSettings.printImage = 'blue_pushpin.gif';
          break;
        case goroam.enm.icons.pushpin.green:
          objSettings.image = 'green_pushpin.png';
          objSettings.printImage = 'green_pushpin.gif';
          break;
        case goroam.enm.icons.pushpin.orange:
          objSettings.image = 'orange_pushpin.png';
          objSettings.printImage = 'orange_pushpin.gif';
          break;
      }
      break;
    case goroam.enm.icons.goroam:
      objSettings = { iconAnchor: new google.maps.Point(8,40), iconSize: new google.maps.Size(34,40), image: 'goroam.png', imageMap: [8,40, 5,31, 0,22, 0,15, 4,8, 8,4, 26,0, 34,0, 34,7, 31,9, 34,13, 34,24, 26,32, 16,35, 11,40 ], infoWindowAnchor: new google.maps.Point(8,40), printImage: 'goroam.gif', printShadow: 'goroam_shadow.gif', shadow: 'goroam_shadow.png', shadowSize: new google.maps.Size(55,40), transparent: 'goroam_transparent.png' };
      break;
  }
  if (objSettings) objResult = goroam.google.maps.create_icon(objSettings, strRootFolder);
  return objResult;
}



/********************************
 * FUNCTION:	find_location
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2006.08.24
 * DESCRIPTION:	This function takes a string describing a location, searches for it and if
 *		found it calls the given callback function.
 * PARAMETERS:	objMap			The GMap to recenter.
 *				strLocation		The location to find.
 *				fCallAfter		Optional. A function to call when done processing the search.  It will be passed the lat/lng
 *                      of the location, a zoom level (if found), and the found address.
 *				fCallAfterNotFound	Optional. A function to call when done processing the search, without finding the lat/lng.
 * RETURNS:	none
 */
goroam.google.maps.find_location = function(objMap, strLocation, fCallAfter, fCallAfterNotFound) {
	var fCallback = function(objGeoResult) {
		var objPoint, strAddress, objPlacemark;
		if ((objGeoResult) && (objGeoResult.Status)) {
			if (objGeoResult.Status.code == 500) {
				// Retry on HTTP failure. Sometimes this results in double attempts
				// but I think the extra is better than not showing any result.
        goroam.google.maps.find_location(objMap, strLocation, fCallAfter);
			} else {
				if ((objGeoResult) && (objGeoResult.Placemark)) {
					if ((objGeoResult.Placemark.length) && (objGeoResult.Placemark.length > 0)) {
            objPlacemark = objGeoResult.Placemark[0];
						objPoint = objPlacemark.Point;
            strAddress = objPlacemark.address;
					} else if (objGeoResult.Placemark.Point) {
            objPlacemark = objGeoResult.Placemark;
						objPoint = objPlacemark.Point;
            strAddress = objPlacemark.address;
					}
					if ((objPoint) && (objPoint.coordinates) && (objPoint.coordinates.length >= 2)) {
						objPoint = new google.maps.LatLng(objPoint.coordinates[1], objPoint.coordinates[0]);
					} else {
						objPoint = undefined;
            strAddress = undefined;
            objPlacemark = undefined;
					}
				}
				if (objPoint) {
          if (fCallAfter) fCallAfter.call(objMap, objPoint, strAddress, objPlacemark);
				} else {
					if (fCallAfterNotFound) {
						fCallAfterNotFound();
					} else {
						alert('<%= Constant::get(:location_not_found) %>' + strLocation);
					}
				}
				//objMap.unset_processing();
			}
		}
	};
	// Search for the location using the GMaps geocoder.
	//objMap.set_processing();
	var objGeocoder = new google.maps.ClientGeocoder();
	objGeocoder.getLocations(strLocation, fCallback);
}



/********************************
 * FUNCTION:	get_address
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.29
 * DESCRIPTION:	This function translates the given lat/lng point to an address.
 * PARAMETERS:	objLatLng   The point to look up.
 *              fCallAfter  The function to call if the address is found.  Will be passed the address string and the
 *                          more detailed GoogleMaps Placemark object.
 * RETURNS:		  none
 */
goroam.google.maps.get_address = function(objLatLng, fCallAfter) {
  var fCallback = function(objGeoResult) {
    var objPlacemark;
    if (objGeoResult && objGeoResult.Placemark && (objGeoResult.Placemark.length > 0)) {
      // Find the most accurate placemark.
      var arrAccuracy = [];
      for (var i = 0; i < objGeoResult.Placemark.length; i++) {
        arrAccuracy[objGeoResult.Placemark[i].AddressDetails.Accuracy] = objGeoResult.Placemark[i];
      }
      if (arrAccuracy.length > 0) objPlacemark = arrAccuracy[arrAccuracy.length - 1];
    } else if (objGeoResult && objGeoResult.Placemark) {
      objPlacemark = objGeoResult.Placemark;
    }
    if (objPlacemark) {
      if (fCallAfter) fCallAfter.call(null, objPlacemark.address, objPlacemark);
    } else {
      alert('<%= Constant::get(:address_for_geo_point_not_found) %>');
    }
  }
	var objGeocoder = new google.maps.ClientGeocoder();
	objGeocoder.getLocations(objLatLng, fCallback);
}



/********************************
 * FUNCTION:	get_hidden_directions_container
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.22
 * DESCRIPTION:	This function gets/creates the container on the page that holds the hidden iframes used in the
 *              cross-domain communication.
 * PARAMETERS:	None
 * RETURNS:	None
 */
goroam.google.maps.get_hidden_directions_container = function(iIndex) {
	iIndex = (iIndex || 0);
	if (!goroam.google.maps.__hidden_directions_container) goroam.google.maps.__hidden_directions_container = [];
  if (!goroam.google.maps.__hidden_directions_container[iIndex]) {
    goroam.google.maps.__hidden_directions_container[iIndex] = document.createElement('div');
    //goroam.google.maps.__hidden_directions_container[iIndex].style.display = 'none';
    document.getElementsByTagName('body')[0].appendChild(goroam.google.maps.__hidden_directions_container[iIndex]);
  }
  return goroam.google.maps.__hidden_directions_container[iIndex];
}



/********************************
 * FUNCTION:	get_map
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.27
 * DESCRIPTION:	This function gets the active map on the page.
 * PARAMETERS:	none
 * RETURNS:		  GoogleMaps Map2 object
 */
goroam.google.maps.get_map = function(strMapId) {
  if (strMapId && (strMapId != '')) goroam.google.maps.load_map_from_settings(strMapId);
  return (goroam.google.maps.__page_maps[strMapId] || goroam.google.maps.__active_map);
}



/********************************
 * FUNCTION:	load
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function is a generalized load function to load a map page.  It will call the optional
 *              function if one is passed in.
 * PARAMETERS:	fFunc   Optional. A more specific function to call during the load process.
 * RETURNS:		  none
 */
goroam.google.maps.load = function(fFunc) {
  if (google.maps.BrowserIsCompatible()) {
    // Extend the Google Maps objects
    goroam.google.maps.extend_functionality();
    // Try to prevent memory leaks.
    goroam.event.addDomListener(window, 'unload', goroam.google.maps.unload);
    // Call the function if given.
    if (fFunc) fFunc();
  } else {
    alert('<%= Constant::get(:error_header) %><%= Constant::get(:error_browser_not_supported) %>');
  }
}



/********************************
 * FUNCTION:	load_active_map
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function simply loads the active map and keeps track of the resultant map object.
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.load_active_map = function() {
  // Load the active map.
  if (goroam.google.maps.load_map_from_settings(goroam.google.maps.__active_map_id)) goroam.google.maps.__active_map = goroam.google.maps.__page_maps[goroam.google.maps.__active_map_id];
}



/********************************
 * FUNCTION:	load_from_page
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function loads the map data from the HTML elements on the page.
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.load_from_page = function() {
  goroam.google.maps.load_active_map();
  // Pull all HTML elements with lat/lng defined.
  var arrLatLngElements = goroam.dhtml.get_elements_with_attribute(goroam.google.maps.__lat_attr + ' , ' + goroam.google.maps.__addr_attr);
  for (var i = 0; i < arrLatLngElements.length; i++) {
    if (((arrLatLngElements[i].getAttribute(goroam.google.maps.__lat_attr) || '') == '') || ((arrLatLngElements[i].getAttribute(goroam.google.maps.__lng_attr) || '') == '')) {
			// If lat or lng is missing, lookup the address using the addr attribute.
		  goroam.google.maps.find_location(arrLatLngElements[i], arrLatLngElements[i].getAttribute(goroam.google.maps.__addr_attr), function(objPoint, strAddress, objPlacemark) {
				if (objPoint) {
					this.setAttribute(goroam.google.maps.__lat_attr, objPoint.lat());
					this.setAttribute(goroam.google.maps.__lng_attr, objPoint.lng());
					goroam.google.maps.process_geotagged_element(this);
				}
				goroam.google.maps.__count_of_processing_addr--;
				if (goroam.google.maps.__count_of_processing_addr <= 0) goroam.google.maps.process_all_geolists();
		  }, function() {
				goroam.google.maps.__count_of_processing_addr--;
				if (goroam.google.maps.__count_of_processing_addr <= 0) goroam.google.maps.process_all_geolists();
			});
			goroam.google.maps.__count_of_processing_addr++;
    } else {
			// If both lat and lng are given, use those values every time, whether not not addr is defined.
			goroam.google.maps.process_geotagged_element(arrLatLngElements[i]);
		}
  }
	if (goroam.google.maps.__count_of_processing_addr <= 0) goroam.google.maps.process_all_geolists();
}



/********************************
 * FUNCTION:	load_map_from_settings
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function loads a map into the container with the given id, using the settings
 *              defined by the javascript request.
 * PARAMETERS:	strId   The id of the container in which to load the map.
 * RETURNS:		  boolean True if the map was loaded successfully; false if not.
 */
goroam.google.maps.load_map_from_settings = function(strId) {
  var bolResult = false;
  var elContainer = document.getElementById(strId);
  if (elContainer && !goroam.google.maps.__page_maps[strId]) {
    var elAnchor = document.createElement('a');
    elAnchor.name = strId;
    elContainer.insertBefore(elAnchor, elContainer.firstChild);
    var objMap = new google.maps.Map2(elContainer);
    objMap.setCenter(new google.maps.LatLng('<%= @settings[:lat] %>', '<%= @settings[:lng] %>'), parseInt('<%= @settings[:zoom] %>'));
    // Add map controls (zooming, map types, etc.)
    try {
			switch ('<%= @settings[:controls] %>') {
				case 'all':
				  objMap.addControl(new GLargeMapControl());
				  objMap.addControl(new GMapTypeControl());
				  objMap.addControl(new GOverviewMapControl());
				  objMap.addControl(new GScaleControl());
					break;
      	case 'all_small':
				  objMap.addControl(new GSmallMapControl());
				  objMap.addControl(new GMenuMapTypeControl());
				  objMap.addControl(new GOverviewMapControl());
				  objMap.addControl(new GScaleControl());
					break;
      	case 'min':
				  objMap.addControl(new GMenuMapTypeControl());
				  objMap.addControl(new GSmallZoomControl());
					break;
      	case 'none':
					break;
			}
    } catch (e) {
      objMap.addControl(new GSmallMapControl());
      objMap.addControl(new GMapTypeControl());
    }
    goroam.google.maps.__page_maps[strId] = objMap;
    bolResult = true;
  }
  return bolResult;
}



/********************************
 * FUNCTION:	add_map_prompt, over_map_element, leave_map_element
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.02.17
 * DESCRIPTION:	This function displays a prompt to show the associated HTML element on a map.  To be used with the
 *              onmouseover/onmouseout events of the element.
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.add_map_prompt = function(elElement) {
  if (!elElement.__map_prompt) {
		var strPosition = '<%= @settings[:position] %>';
		var strOutside = '';
		if (strPosition.left(4) == 'out_') {
			strOutside = '_' + strPosition;
			strPosition = strPosition.right(2);
		}
    // Add event triggers to the element to show/hide the map prompt.
    goroam.event.bindDom(elElement, 'mouseover', elElement, goroam.dhtml.set_mouseover);
    goroam.event.bindDom(elElement, 'mouseover', elElement, goroam.google.maps.over_map_element);
    goroam.event.bindDom(elElement, 'mouseout', elElement, goroam.dhtml.unset_mouseover);
    goroam.event.bindDom(elElement, 'mouseout', elElement, goroam.google.maps.leave_map_element);
    goroam.event.bindDom(elElement, 'click', elElement, function(e) { if (this.__map_prompt && this.__map_prompt.__mouseover) goroam.dhtml.cancel_bubble(e); });
		// Create an anchor to be able to reference this location later.
    var elAnchor = document.createElement('a');
		elAnchor.style.position = 'absolute';
		elAnchor.name = '_latlng' + goroam.google.maps.__count_of_page_lat_lng++;
		elAnchor.id = elAnchor.name;
		if (goroam.browser.host_info().name == goroam.enm.browsers.ie) elAnchor.innerHTML = '&nbsp;';
    // Create a link to trigger the onclick event and move to the map's anchor on the page.
    var elLink = document.createElement('a');
    elLink.href = '#' + goroam.system.set_default(elElement.getAttribute(goroam.google.maps.__map_attr), '<%= @settings[:map] %>');
    // The link is just a transparent image that fits the size of the container; this allows for controlling
    // the display through CSS.
    elLink.innerHTML = '<img src="<%= Constant::get(:root_url) %>/images/px.gif" style="border-width:0px; height:100%; width:100%;" title="<%= Constant::get(:show_on_map_prompt_text) %>" />';
    // Create the container that holds the link and is the vessel for display styles.
    elElement.__map_prompt = document.createElement('div');
		elElement.__map_prompt.__anchor = elAnchor.name;
    elElement.__map_prompt.className = '<%= Constant::get(:css_prefix) %>map_prompt <%= Constant::get(:css_prefix) %>map_prompt_' + strPosition;
    elElement.__map_prompt.appendChild(elLink);
    // When hovering over the map prompt, use this class name instead of the default.
    elElement.__map_prompt.__mouseover_class_name = 'map_prompt_hover';
    elElement.__map_prompt.__mouseout_class_name = 'map_prompt_hover_element';
    goroam.event.bindDom(elLink, 'click', elElement, goroam.google.maps.show_on_map);
    goroam.event.bindDom(elElement.__map_prompt, 'mouseover', elElement.__map_prompt, goroam.dhtml.set_mouseover);
    goroam.event.bindDom(elElement.__map_prompt, 'mouseout', elElement.__map_prompt, goroam.dhtml.unset_mouseover);
    goroam.event.bindDom(elElement.__map_prompt, 'mouseout', elElement, goroam.google.maps.leave_map_element);
    // Make sure the HTML element is positioned, so that the absolute positioning of the map prompt works correctly.
    if (elElement.style.position != 'absolute') elElement.style.position = 'relative';
    if (elElement.tagName.toLowerCase() == 'img') {
      // Images do not have child elements, so drop it in a parent span and add the map prompt as a sibling node,
      // instead of a child node.
      var elSpan = document.createElement('span');
      // Transfer positioning to the parent span.
      elSpan.style.position = elElement.style.position;
      elElement.style.position = 'relative';
      elSpan.style.top = elElement.style.top;
      elSpan.style.bottom = elElement.style.bottom;
      elSpan.style.left = elElement.style.left;
      elSpan.style.right = elElement.style.right;
			elSpan.className = '<%= Constant::get(:css_prefix) %>img_container';
      // IE Hack to give the parent element "layout".
      if (goroam.browser.host_info().name == goroam.enm.browsers.ie) elSpan.style.zoom = 1;
      // Clear positioning from the image so that is uses the positioning transferred to the parent span.
      elElement.style.top = '';
      elElement.style.bottom = '';
      elElement.style.left = '';
      elElement.style.right = '';
      // Insert the parent span into the DOM tree.
      elElement.parentNode.replaceChild(elSpan, elElement);
      elSpan.appendChild(elElement);
      elSpan.appendChild(elElement.__map_prompt);
			// Insert an anchor to be able to navigate to this location.
			elSpan.insertBefore(elAnchor, elElement);
    } else {
      // IE Hack to give the parent element "layout".
      if ((goroam.browser.host_info().name == goroam.enm.browsers.ie) && elElement.currentStyle && !elElement.currentStyle.hasLayout) elElement.style.zoom = 1;
      elElement.appendChild(elElement.__map_prompt);
			// Tag the element with a class name so it can be accessed through CSS.
			goroam.dhtml.edit_class_name(elElement, 'tagged_element' + strOutside);
			// Insert an anchor to be able to navigate to this location.
			elElement.parentNode.insertBefore(elAnchor, elElement);
    }
  }
	return elElement.__map_prompt.__anchor;
}
goroam.google.maps.over_map_element = function() {
  if (!this.__map_prompt.__mouseover) goroam.dhtml.edit_class_name(this.__map_prompt, 'map_prompt_hover_element');
}
goroam.google.maps.leave_map_element = function() {
  var self = this;
  window.setTimeout(function() { if (!self.__mouseover && !self.__map_prompt.__mouseover) goroam.dhtml.edit_class_name(self.__map_prompt, '', 'map_prompt_hover_element'); }, parseInt('<%= Constant::get(:exit_hover_timeout) %>'));
}



/********************************
 * FUNCTION:	process_all_geolists
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.14
 * DESCRIPTION:	This function processes all a geotagged HTML lists (UL or OL).
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.process_all_geolists = function() {
	// Pull and process all lists with geotagged children.
	var arrTagNames = ['ul', 'ol'];
	for (var j = 0; j < arrTagNames.length; j++) {
		var arrLists = document.getElementsByTagName(arrTagNames[j]);
		for (var i = 0; i < arrLists.length; i++) {
			goroam.google.maps.process_geolist(arrLists[i]);
		}
	}
}



/********************************
 * FUNCTION:	process_geolist
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.14
 * DESCRIPTION:	This function loads a geotagged HTML list (UL or OL).
 * PARAMETERS:	elList		The HTML UL or OL element to process.
 * RETURNS:		  none
 */
goroam.google.maps.process_geolist = function(elList) {
	var arrCounts = {};
	if ((elList.tagName.toLowerCase() == 'ul') || (elList.tagName.toLowerCase() == 'ol')) {
		// If the list has no text, assume it is only there to define a map route.
		if (goroam.dhtml.get_inner_text(elList).compress_whitespace().trim() == '') goroam.dhtml.edit_class_name(elList, 'map_route');
		var strRouteType = (elList.className.match(/\b(gr_)?map_route_(walking|driving)\b/i) || [''])[0].right_of('map_route_').toLowerCase();
		// Pull all geotagged children.
		var arrTagged = goroam.dhtml.get_elements_with_attribute(goroam.google.maps.__lat_attr + ' , ' + goroam.google.maps.__addr_attr, elList);
		if (arrTagged.length > 0) {
			goroam.dhtml.edit_class_name(elList, 'geo_list');
			var strId = (elList.id || '');
			var strColor = elList.style.color;
			var iWidth = parseInt(elList.style.width);
			var dOpacity = elList.style.opacity;
			if (strId == '') elList.id = goroam.math.random_string(30);
			for (var i = 0; i < arrTagged.length; i++) {
				var objMap = goroam.google.maps.get_map(arrTagged[i].getAttribute(goroam.google.maps.__map_attr));
				if (objMap) {
					var strMapId = objMap.getContainer().id;
					if (arrCounts[strMapId]) {
						arrCounts[strMapId]++;
					} else {
						arrCounts[strMapId] = 0;
					}
					if (((arrTagged[i].getAttribute(goroam.google.maps.__lat_attr) || '') == '') || ((arrTagged[i].getAttribute(goroam.google.maps.__lng_attr) || '') == '')) {
						// If lat or lng is missing, lookup the address using the addr attribute.
						var iIndex = arrCounts[strMapId];
						goroam.google.maps.find_location(arrTagged[i], arrTagged[i].getAttribute(goroam.google.maps.__addr_attr), function(objPoint, strAddress, objPlacemark) {
							if (objPoint) {
								this.setAttribute(goroam.google.maps.__lat_attr, objPoint.lat());
								this.setAttribute(goroam.google.maps.__lng_attr, objPoint.lng());
								objMap.add_point_to_line(strId, objPoint, iIndex, strRouteType, strColor, iWidth, dOpacity);
							}
						}, true);
					} else {
						// If both lat and lng are given, use those values every time, whether not not addr is defined.
						objMap.add_point_to_line(strId, new google.maps.LatLng(arrTagged[i].getAttribute(goroam.google.maps.__lat_attr), arrTagged[i].getAttribute(goroam.google.maps.__lng_attr)), arrCounts[strMapId], strRouteType, strColor, iWidth, dOpacity);
					}
					if (arrTagged[i].tagName.toLowerCase() == 'li') goroam.dhtml.edit_class_name(arrTagged[i], 'geo_tag_only');
				}
			}
		}
	}
}



/********************************
 * FUNCTION:	process_geotagged_element
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.10.12
 * DESCRIPTION:	This function encapsulated the logic required to process an element that has been tagged with lat/lng attributes.
 * PARAMETERS:	elElement		The HTML element to process.
 * RETURNS:		  none
 */
goroam.google.maps.process_geotagged_element = function(elElement) {
	var bolShowOnMap = true;
	// For geopoints that indicate a line, don't add a marker on the map.
	if (elElement.tagName.toLowerCase() == 'li') {
		var objData = goroam.dhtml.get_inner_text(elElement);
		if ((objData.title == '' || objData.title == null) && (objData.value == '' || objData.value == null)) bolShowOnMap = false;
	}
	if (bolShowOnMap) {
		// Add a map prompt to the element.
		var strAnchor = '';
		if ((elElement.tagName.toLowerCase() == 'img') || (goroam.dhtml.get_inner_text(elElement) != '')) strAnchor = goroam.google.maps.add_map_prompt(elElement);
		var objMap = goroam.google.maps.get_map(elElement.getAttribute(goroam.google.maps.__map_attr));
		if (objMap) {
			var objData = goroam.dhtml.get_element_data(elElement);
			var strAnchorText = (objData.title || '');
			if (strAnchorText == '') strAnchorText = (objData.value || '');
			if (strAnchorText.length > 25) strAnchorText = strAnchorText.left(25) + '...';
		  var objLatLng = objMap.add_lat_lng(elElement.getAttribute(goroam.google.maps.__lat_attr), elElement.getAttribute(goroam.google.maps.__lng_attr), strAnchor, strAnchorText);
		  // Add event triggers to highlight the element when hovering over the map marker.
		  goroam.event.bind(objLatLng, 'mouseover', elElement, goroam.dhtml.highlight);
		  goroam.event.bind(objLatLng, 'mouseout', elElement, goroam.dhtml.unhighlight);
			if (objLatLng.__menu) {
				goroam.event.bindDom(objLatLng.__menu.get_container().lastChild, 'mouseover', elElement, goroam.dhtml.highlight);
				goroam.event.bindDom(objLatLng.__menu.get_container().lastChild, 'mouseout', elElement, goroam.dhtml.unhighlight);
			}
		  // Resize and recenter the maps based on the loaded lat/lng points.
		  objMap.resize_to_bounds();
		}
	}
  // Send the element data back to the GoRoam server.
  goroam.xdcomm.send_element(elElement);
}



/********************************
 * FUNCTION:	show_on_map
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.02.17
 * DESCRIPTION:	This function displays an item on a map, which may be either on the page on in a popup (based on
 *              the api settings).
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.show_on_map = function(e) {
  var bolResult = false;
  var bolPopup = ('<%= @settings[:popup] == nil ? "false" : "true" %>' == 'true' ? true : false);
  var bolPopupWindow = ('<%= @settings[:popup_window] == nil ? "false" : "true" %>' == 'true' ? true : false);
  var strMapId = (this.getAttribute(goroam.google.maps.__map_attr) || goroam.google.maps.__active_map_id);
  var objMap = goroam.google.maps.get_map(strMapId);
  if (objMap && !(bolPopup || bolPopupWindow)) {
    var objLatLng = new google.maps.LatLng(this.getAttribute(goroam.google.maps.__lat_attr), this.getAttribute(goroam.google.maps.__lng_attr));
    objMap.setCenter(objLatLng);
    objMap.show_focus(objLatLng);
    bolResult = true;
  } else if (bolPopupWindow) {
    goroam.dhtml.cancel_bubble(e);
    var objChildWindow = goroam.controls.popup_window('<%= Constant::get(:root_url) %>/' + this.getAttribute(goroam.google.maps.__lat_attr) + '/' + this.getAttribute(goroam.google.maps.__lng_attr) + '?layout=min&find=' + goroam.dhtml.get_element_data(this).value, 482, 620, strMapId, false, true);
    objChildWindow.focus();
  } else {
    goroam.controls.popup_map(new google.maps.LatLng(this.getAttribute(goroam.google.maps.__lat_attr), this.getAttribute(goroam.google.maps.__lng_attr)));
    goroam.dhtml.cancel_bubble(e);
  }
  return bolResult;
}



/********************************
 * FUNCTION:	unload
 * WRITTEN BY:	Ryan Martin
 * WRITTEN ON:	2009.01.25
 * DESCRIPTION:	This function does any necessary cleanup when the user leaves the page.
 * PARAMETERS:	none
 * RETURNS:		  none
 */
goroam.google.maps.unload = function() {
  google.maps.Unload();
}

